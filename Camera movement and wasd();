/** CAMERA MOVEMENT TEST AND KEYBOARD MOVEMENT SIMULATOR **/

/** PURPOSE: TO TRY AND PLAY AROUND WITH DIFFERENT CAMERA ANGLES WHILE KEEPING THE SCENE IN STEADY IN DIFFERENT AREAS OF SCENERY**/
/*mapX & mapY values that map out the entire area, 

TODO:
1. Finish up the stationary scrolling on the left side
2. Start and finsih transition from stationary scrolling to tradional scrolling
2. Setup mapX and mapY array values for maps - STARTED 4/6
3. Setup different Scene Sizes for those coordinates
4. Organize everything in a more concise manner with commenting
*/

//starting map position through mapX and mapY values
var mapX = 0;
var mapY = 0;
var GameMapX = [[800,600,600],
           [500,600,900]];
var GameMapY = [[600,700,800],
[500,600,900]];
//array for keyboard command movement (seen later down)
var keys = [];

//properties for the moving ellipse
var obj = {
    mapX: 300,
    mapY: 300,
    width: 100,
    height: 100,
    ellipse: function(){
    },
};
//the sizes for each and every individual (when done) scene on the map ( - Must make an array for each corresponding mapX and mapY value - )
//variable to boolean the difference between stationary and traditional scrolling
var Stationary = false;
var SceneMove = false; //variable that stops the ellipses' movement momentarily as the map adjusts

//Properties and logic of the scenes
var scene = {
    sizeX: GameMapX[mapY][mapX],
    sizeY: GameMapY[mapY][mapX], 
    //current camera movement of the scene 
    x: 0,
    y: 0,
collision: { //collision detections
    RightX: (scene.sizeX- scene.collision.width),
    TopY: (-scene.sizeY+scene.collision.width+height),
    LeftX: (-scene.sizeX+scene.collision.width+width),
    BottomY: (scene.sizeY-scene.collision.width),
    width: 10, //width of detection range
    active: function(a,b) //active detection function (uses mapX & mapY)
    {
        if(Stationary) //stationary camera logic
        { 
            
            var cameraIf = false;
            if(scene.x+width < scene.collision.RightX && 
            (scene.x) > scene.collision.LeftX || 
            (obj.mapX >scene.collision.LeftX+width/2) && 
            (obj.mapX <scene.collision.RightX- width/2))
           {
           
            println("it works");
            scene.x = obj.mapX-width/2;
           
           }
           if(scene.y+width < scene.collision.BottomY && 
            (scene.y) > scene.collision.TopY || 
            (obj.mapY >scene.collision.TopY+height/2) && 
            (obj.mapY <scene.collision.BottomY- height/2))
           {
           
            println("it works");
            scene.y = obj.mapY-height/2;
        }
        }
        
        //Right Scroll detection
        if((obj.mapX-scene.collision.RightX)>=25+(scene.sizeX*(a)))
        {
            Stationary = false;
                SceneMove = true;
                if(SceneMove)
                {
                scene.x+= cos(1)*8;
                    if(scene.x >=scene.sizeX*(a+1))
                    {
                        mapX++;
                        SceneMove = false;
                    }
                }
        }
        //Bottom Scroll detection
        if((obj.mapY-scene.collision.BottomY)>=25+(scene.sizeY*(b)))
        {
            Stationary = false;
                SceneMove = true;
                if(SceneMove)
                {
                scene.y+= cos(1)*8;
                    if(scene.y >=scene.sizeX*(b+1))
                    {
                        mapY++;
                        SceneMove = false;
                    }
                }
        }
        //Top Scroll detection
        if((obj.mapY-scene.collision.TopY)<=-25+(scene.sizeY*(b)))
        {
            Stationary = false;
                SceneMove = true;
                if(SceneMove)
                {
                scene.y-= cos(1)*8;
                    if(scene.y <=scene.sizeX*(b-1))
                    {
                        mapY--;
                        SceneMove = false;
                    }
                }
        }
        //Left Scroll detection
        if((obj.mapX-scene.collision.LeftX)<=-25+(scene.sizeX*(a)))
        {
            Stationary = false;
                SceneMove = true;
                if(SceneMove)
                {
                scene.x-= cos(1)*8;
                    if(scene.x <=scene.sizeX*(a-1))
                    {
                        mapX--;
                        SceneMove = false;
                    }
                }
        }
        if(scene.sizeX > width || scene.sizeY > height)
{
    Stationary = true;
}
    },
}
};
fill(0,0,0);
//the circle that fill in as our test character
obj.ellipse = function(){
    ellipse(obj.mapX-scene.x,obj.mapY-scene.y,obj.width,obj.height);
};
//Logic for the key presses that in turn becomes the movement
var firstClick = []; //array used for when the key is only pressed once
keyPressed = function() {
    
    if (keys[keyCode]) {
        firstClick[keyCode] = false; //makes it false so that it is only one
    } else {
        firstClick[keyCode] = true; // first time you click
    }
    
    keys[keyCode] = true; //adds into the keys array as true
}; 
keyReleased = function() {
    keys[keyCode] = false; //gets rid of value from keys array by setting it as false
    firstClick[keyCode] = false; //makes it false so that it is only one
};
var wasd = function() //variable just to organize it and make it easier to access
{ if (!SceneMove)
{
        if(keys[68] )
    {//println("it d");
        obj.mapX+= 2;
    }
    if(keys[65])
    {//println("it a");
        obj.mapX-= 2;
    }
    if(keys[87])
    {//println("it w");
        obj.mapY-= 2;
    }
    if(keys[83])
    {//println("it s");
        obj.mapY+= 2;
    }
}
};
draw = function() {
    background(255,255,255);
    wasd();
    fill(8, 8, 8);
    scene.sizeX  = GameMapX[mapY][mapX];
    scene.sizeY  = GameMapY[mapY][mapX];
obj.ellipse(); //ellipse character and random rect placed throughout several locations to prove that camera is functioning
    //rect(scene.collision.LeftX,0,10,500);
    rect(100-scene.x,800-scene.y,100,100);
    rect(100-scene.x,100-scene.y,100,100);
    rect(-800-scene.x,0-scene.y,100,100);
    rect(800-scene.x,0-scene.y,100,100);
    scene.collision.active(mapX,mapY);
    /**** Final Test ( - NOT DONE - )
     * Find squares at coordinates:
     * (_,_),(_,_),(_,_), & (_,_),
****/


/** ACTIVE DEBUGGING **/
//println(obj.mapX);
//println(obj.mapY);
//println(scene.x-width/2);
//println(-scene.y+width);
//println(Stationary);
//println(mapX);
//println(mapY);
//println(scene.collision.LeftX+width/2);
//println(scene.sizeX);
//println(scene.sizeY);
};

